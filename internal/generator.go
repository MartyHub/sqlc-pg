package internal

import (
	"bytes"
	"embed"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"text/template"

	j "github.com/dave/jennifer/jen"

	"github.com/MartyHub/gid"
	"github.com/MartyHub/sqlc-pg/plugin"
)

const (
	pgxImport     = "github.com/jackc/pgx/v5"
	minStructSize = 2
	source        = "github.com/MartyHub/sqlc-pg"
)

//go:embed templates/*.tmpl
var tpls embed.FS

type Generator struct {
	cfg     Config
	errs    []error
	files   map[string]*j.File
	req     *plugin.CodeGenRequest
	structs []StructMetadata
	tok     gid.Tokenizer
	tpl     *template.Template
}

func New(req *plugin.CodeGenRequest) (*Generator, error) {
	cfg, err := newConfig(req)
	if err != nil {
		return nil, err
	}

	tpl, err := template.ParseFS(tpls, "templates/*.tmpl")
	if err != nil {
		return nil, err
	}

	result := &Generator{
		cfg:   cfg,
		files: make(map[string]*j.File),
		req:   req,
		tok:   gid.Default(),
		tpl:   tpl,
	}

	return result, nil
}

func (gen *Generator) Generate() (*plugin.CodeGenResponse, error) {
	gen.genCatalog()
	gen.genRepositories()

	return gen.updateResponse()
}

func (gen *Generator) genCatalog() {
	for _, schema := range gen.req.Catalog.Schemas {
		if schema.Name == "pg_catalog" || schema.Name == "information_schema" {
			continue
		}

		for _, e := range schema.Enums {
			gen.file(schema.Name).Add(gen.enum(e))
		}

		if gen.cfg.EmitTableNames && len(schema.Tables) > 0 {
			gen.file(schema.Name).
				Const().
				DefsFunc(func(group *j.Group) {
					for _, t := range schema.Tables {
						group.Id(gen.tok.ExportID("Table_" + t.Rel.Name)).Op("=").Lit(t.Rel.Name)
					}
				})
		}
	}
}

func (gen *Generator) computeRepositories() map[string]*RepositoryMetadata {
	result := make(map[string]*RepositoryMetadata)

	for _, query := range gen.req.Queries {
		name := gen.fileName(fileNameWithoutExt(query.Filename))
		repo, found := result[name]

		if !found {
			repo = &RepositoryMetadata{Name: name + "Repository"}

			result[name] = repo
		}

		params, paramsFound := gen.lookup(gen.queryParamStruct(query))
		row, rowFound := gen.lookup(gen.queryRowStruct(query))

		repo.Queries = append(repo.Queries, QueryMetadata{
			Query:            query,
			Name:             query.Name,
			Params:           params,
			ParamsToGenerate: !paramsFound,
			Row:              row,
			RowToGenerate:    !rowFound,
		})
	}

	return result
}

func (gen *Generator) initRepositories(repositories map[string]*RepositoryMetadata) {
	for name, repo := range repositories {
		f := gen.file(gen.fileName(name))

		sort.Slice(repo.Queries, func(i, j int) bool {
			return repo.Queries[i].Name < repo.Queries[j].Name
		})

		f.ImportName(pgxImport, "pgx")
		f.Add(gen.repository(repo))
	}
}

func (gen *Generator) genRepositories() {
	repositories := gen.computeRepositories()

	gen.initRepositories(repositories)

	for repoName, repo := range repositories {
		for _, query := range repo.Queries {
			f := gen.file(repoName)

			f.Add(gen.queryStmt(query.Query))

			if query.ParamsToGenerate && len(query.Params.Fields) >= minStructSize {
				f.Add(query.Params.Definition(gen.cfg))
			}

			if query.RowToGenerate {
				if len(query.Row.Fields) >= minStructSize {
					f.Add(query.Row.Definition(gen.cfg))
				}

				if !query.Row.Empty() {
					f.Add(gen.queryScanFunc(query.Row))
				}
			}

			f.Add(gen.queryFunc(repo, query))
		}
	}
}

func (gen *Generator) updateResponse() (*plugin.CodeGenResponse, error) {
	result := &plugin.CodeGenResponse{
		Files: []*plugin.File{
			{
				Name: gen.cfg.OutputDBFileName,
				Contents: gen.genTemplate("db.tmpl", map[string]any{
					"Package": gen.cfg.Package,
					"Source":  source,
					"Version": Version,
				}),
			},
		},
	}

	if gen.cfg.DumpInput {
		data, err := json.MarshalIndent(gen.req, "", "  ")
		if err != nil {
			gen.errs = append(gen.errs, err)
		}

		result.Files = append(result.Files, &plugin.File{
			Name:     "input.json",
			Contents: data,
		})
	}

	for name, file := range gen.files {
		file.HeaderComment(fmt.Sprintf("// Code generated by %s %s\n// DO NOT EDIT", source, Version))

		buf := &bytes.Buffer{}

		if err := file.Render(buf); err != nil {
			gen.errs = append(gen.errs, err)
		}

		result.Files = append(result.Files, &plugin.File{
			Name:     name,
			Contents: buf.Bytes(),
		})
	}

	return result, errors.Join(gen.errs...)
}

func (gen *Generator) lookup(str StructMetadata) (StructMetadata, bool) {
	for _, exist := range gen.structs {
		if exist.Match(str) {
			return exist, true
		}
	}

	gen.structs = append(gen.structs, str)

	return str, false
}

func (gen *Generator) genTemplate(name string, data any) []byte {
	buf := bytes.Buffer{}

	if err := gen.tpl.ExecuteTemplate(&buf, name, data); err != nil {
		gen.errs = append(gen.errs, err)
	}

	return buf.Bytes()
}

func (gen *Generator) file(name string) *j.File {
	fileName := name + gen.cfg.OutputFilesSuffix + ".go"

	f, found := gen.files[fileName]
	if !found {
		f = j.NewFile(gen.cfg.Package)

		gen.files[fileName] = f
	}

	return f
}
